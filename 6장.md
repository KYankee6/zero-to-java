# 6. 클래스
## 6.1 객체 지향 프로그래밍
현실 세계에서 어떤 제품을 만들 때, 부품을 만들고 이를 조립해서 완성된 제품을 만들 듯이, SW를 개발할때도 부품에 해당하는 `객체`를 만들고, 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을 객체 지향 프로그래밍(OOP)라고 한다.
(추가할 내용이 많겠지만, 일단 그런 걸로 🙄)


### 6.1.1 객체란?
객체(Object)란 물리적으로 존재하거나, 추상적으로 생각할 수 있는 것 중에 `속성`을 가지고 `식별 가능한 것`을 말한다.
객체는 `속성`과 `동작`으로 구성되어 있다.
자바에서는 이를 `필드`와 `메소드(method)`라고 부른다.
> - 객체 모델링의 예시.
현실 세계 객체의 속성/동작을 추려내어 소프트웨어 객체의 필드/메소드로 정의하는 과정
![](https://velog.velcdn.com/images/petit-prince/post/ad7606e2-40d2-4679-b145-8e61c27d544e/image.png "객체 예시")

### 6.1.2 객체의 상호작용
- 객체들은 각각 `독립적`으로 존재하고, 다른 객체와 서로 **상호작용** 하면서 동작한다. 
- 객체들 사이의 상호작용 수단은 `메소드`이다.
- 메소드 호출은 다음과 같은 형태를 가진다.
> 리턴값 = 객체.메소드(매개값1, 매개값2 ...)
- 매개값은 메소드를 실행하기 위해 필요한 데이터이다.
- 리턴값은 메소드가 실행하고 나서 호출한 곳으로 돌려주는 값이다.

### 6.1.3 객체 간의 관계
- 객체는 개별적으로 사용 될 수 있지만, 대부분 다른 객체와 `관계`를 맺는다.
- `집합`, `사용`, `상속` 관계가 있다.
	- 집합: 하나는 부품이고 하나는 완성품 (ex 자동차 - 핸들, 엑셀 ...)
	- 사용: 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다 (ex 사람 - 자동차)
	- 상속: 부모 객체를 기반으로 하위 객체를 생성하는 관계, 일반적으로 부모는 종류를, 자식 객체는 구체적 사물에 해당한다 (ex 자동차 - 기계)

### 6.1.4 객체 지향 프로그래밍의 특징
#### 1. 캡슐화
객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
외부 객체는 내부의 구조를 알지 못하며, 제공하는 필드와 메소드만 이용할 수 있다.
외부의 **잘못된 사용으로 인해 객체가 손상되지 않도록** 한다.
이를 위해 `접근 제한자`를 사용한다.
    
#### 2. 상속
부모가 가지고 있는 재산을 자식에게 물려주는 것
부모 객체는 자신의 필드와 메소드를 하위 객체에게 물려주어 사용할 수 있도록 한다.
부모 객체 재사용으로 하위 객체 빠르고 쉽게 설계한다. 즉, **반복된 코드를 줄여준다**

#### 3. 다형성
다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.
하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용하게 한다.
자바는 다형성을 위해 부모 클래스, 인터페이스의 타입 변환을 허욯나다.
부모 타입에는 모든 자식객체가 대입 될 수 있고. 모든 인터페이스 타입의 구현객체가  대입 될 수 있다. (LSP)
>ex) (인터페이스) 자동차의 바퀴 - (구현체) 경주용, 일반용

## 6.2 객체와 클래스
사용하고 싶은 객체가 있다면 설계도(Java의 Class)가 필요하다.
클래스(설계도)에는 객체를 생성하기 위한 필드/메소드가 정의되어 있다.
클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.
(ex 자동차 객체 -> 자동차 클래스의 인스턴스)
클래스로부터 ㅇ객체를 만드는 과정을 인스턴스화라고 한다.
객체 지향 프로그래밍 개발은 세가지 단계가 있다.
> 1. 클래스 설계
> 2. 클래스를 가지고 사용할 객체를 생성
> 3. 객체 이용

## 6.3 클래스 선언
자바의 식별자 작성 규칙에 따라 만들어야 한다.
클래스 이름이 단일 단어라면 첫 자를 대문자로, 나머지를 소문자로 작성한다.
만약 서로 다른 단어가 혼합된 이름을 사용한다면, 각 단어의 첫 머리 글자를 대문자로 작성하는 것이 관례다.
주의할 점은 파일 이름과 동일한 이름의 클래스 선언에만 `public` 접근 제한자를 붙일 수 있다.
가급적이면 소스 파일 하나당 동일한 이름의 클래스 하나를 선언하는 것이 좋다.
> 자세한 사항은 [Oracle 자바 네이밍 컨벤션](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html)을 참고하자

## 6.4 객체 생성과 클래스 변수
클래스로부터 객체를 생성하는 방법은 다음과 같이 `new` 연산자를 사용하면 된다.
```java
클래스 변수명 = new 클래스();
```
- `new`는 클래스로부터 객체를 생성시키는 연산자이다.
- `new` 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.
- `new` 연산자로 생성된 객체는 **메모리 힙 영역에 생성된다.** (객체 주소를 리턴한다.)

> 클래스는 두가지 용도가 있다.
> **라이브러리(API)**와 **실행용**으로 나뉜다.
> 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 **라이브러리**이고 나머지는 **실행 클래스**이다.
> 분리 안할 수 있지만, 분리해야 한다.

> **라이브러리**는 다른 클래스에서 이용할 목적으로 설계된다.
> **실행 클래스**는 프로그램 실행 진입점인 main() 메소드를 제공한다.

![](https://velog.velcdn.com/images/petit-prince/post/15615845-192c-45f9-80a6-af41d845df20/image.png "객체 생성과 클래스 변수")

## 6.5 클래스의 구성 멤버
클래스의 구성멤버에는 `필드`, `생성자`, `메소드`가 있다.
```java
public class ClassName{
	//필드
	int fieldName;
    
    //생성자
    ClassName();
    
    //메소드
    void methodName();
}
```

### 6.5.1 필드
객체의 데이터가 저장되는 곳

고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다.
선언 형태는 변수와 비슷하지만, `필드`를 변수라고 부르지 않는다.

> 필드와 변수의 차이
변수는 생성자와 메소드 내에서만 사용되고, 생성자와 멤소드가 실행 종료되면 자동 소멸된다.
 하지만 `필드`는 생성자, 메소드 전체에 사용되며 객체 소멸 전까지 존재한다.
 
### 6.5.2 생성자
객체 생성 시 초기화 역할 담당한다.
필드를 초기화 하거나, 메소드를 호출해서 객체를 사용할 준비를한다. 생성자는 메소드와 비슷하게 생겼지만 **클래스 이름**으로 되어있고, **리턴값이 없다.**

### 6.5.3 메소드
메소드는 객체의 동작에 해당되는 블록이다.
메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
메소드는 `필드`를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해 다양한 기능을 수행 하기도 한다.
메소드는 객체 간의 데이터 전달의 수단으로 사용된다.
외부로부터 매개값을 받거나, 값을 리턴할 수도 있다.3

## 6.6 필드
다시 한번, **필드와 변수는 다르다.**
또, 클래스 멤버 변수라는 표현도 있지만, **필드**로 사용하자.
- 초기값이 지정되지 않은 필드들은 객체 생성시 자동으로 기본 초기값으로 설정된다.
- 기본 타입(정수, 실수, 논리)는 `0, OL, 0.0, \u0000(빈 공백) 등`으로 초기화 된다.
- 참조 타입은 `null`로 초기화된다.
- 클래스 내부에서는 필드명으로 접근할 수 있다.
- 그러나 필드를 **클래스 외부에서** 사용하려면, 객체를 생선한 뒤 필드를 사용해야 한다.
- 필드는 `객체`에 소속된 데이터이므로 `객체`가 존재하지 않으면 필드도 존재하지 않는다.

## 6.7 생성자
생성자는 `new` 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.
생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.
`new` 연산자에 의해 생성자가 실행되면 힙 영역에 객체가 생성되고 그 주소가 리턴된다.
만약 에러가 발생하면 객체는 생성되지 않는다.

### 6.7.1 기본 생성자
모든 클래스는 생성자가 **반드시 존재하며**, 하나 이상을 가질 수 있다.
클래스가 `public` 클래스로 선언되면 기본 생성자에도 `public`이 붙지만, 클래스가 `public`생성자가 없이 클래스로만 선언되면 기본 생성자에도 `public`이 붙지 않는다.
그러나 클래스에 명시적으로 선언한 생성자가 한 개라도 있으면, 컴파일러는 기본 생성자를 추가하지 안늖다.

### 6.7.2 생성자 선언
매개 변수 선언은 생략할 수도 있고, 여러개를 선언해도 좋다.
```java
public class Car{
	// codes..
    // 생성자
	Car(String model, String color, int maxSpeed);
}

Car myCar = new Car("그랜저", "검정", 300);
```

클래스에 생성자가 명시적으로 선언되어 있을 경우에는 **반드시 선언된 생성자를 호출해서 객체를 생성해야만 한다.**

### 6.7.3 필드 초기화
클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다.
만약 다른 값으로 초기화하고 싶다면 두가지가 있다. 
```java
//1. 필드 선언할 때 초기화
pulbic class Korean{
	String nation = "대한민국";
    String name;
    String ssn;
}
Korean k1 = new Korean();
soutv(k1.nation); //대한민국
```
